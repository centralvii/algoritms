# Конспекты по алгоритмам

### Оглавление

1. Алгоритмы и объекты
  + [Принципы ООП (эволюция классов)](#OOP);
  + [Синхронность и асинхронность](#async);
  + [Алгоритмический доступ к данным](#algdost)
  + [Базовые операторы алгоритмов](#base)

## <a name="OOP"></a> ООП (эволюция классов)

Можно сравнить с древом эволюции или с семейным древом, где каждый объект это
экземпляр у которого есть свои разные свойства, но у них общий родитель.

![](https://i.imgur.com/x8ywbz8.png)

### Принципы ООП
```
1. Наследования - заимствование структуры (генов) и методов (способностей) у родителя
2. Полиморфизм - способность выполнять действия разными способами 
3. Инкапсуляция - роль контейнера характиристик (свойства) и способностей (методов) 
```
### Основные понятия ООП

* **Класс:** Это как чертеж для создания объекта. Он определяет свойства и методы (действия) объекта. Например, класс "Собака" может иметь свойства "порода", "цвет", "кличка" и методы "лаять", "бегать", "есть". 
* **Объект:** Это конкретная реализация класса, то есть отдельная "собака" с определенными значениями свойств. Например, объект "Белка" класса "Собака" может иметь свойства "порода" = "хаски", "цвет" = "белый", "кличка" = "Белка".
* **Свойства:** Это характеристики объекта, которые описывают его состояние. Например, для класса "Автомобиль" свойствами могут быть "цвет", "марка", "год выпуска".
* **Методы:** Это действия, которые объект может выполнять. Например, для класса "Автомобиль" методами могут быть "ехать", "тормозить", "заправляться".
* **Наследование:** Это механизм, позволяющий создавать новые классы на основе существующих. Например, класс "СпортивныйАвтомобиль" может наследовать все свойства и методы класса "Автомобиль" и добавлять свои собственные (например, "максимальная скорость").
* **Инкапсуляция:** Это принцип, который заключается в том, что внутренняя реализация объекта скрыта от внешнего мира. То есть, чтобы изменить состояние объекта, мы используем специальные методы (методы доступа).
* **Полиморфизм:** Это способность объектов разных классов реагировать по-разному на один и тот же вызов метода. Например, метод "говорить" для класса "Собака" будет вызывать лай, а для класса "Кошка" — мяуканье.

![alt](https://i.imgur.com/reQUQXh.png)

### Почему ООП полезно?
Структуризация кода: 
- ООП позволяет разбить сложные программы на более мелкие, понятные части.
- Повторное использование кода: Наследование позволяет создавать новые классы на основе существующих, что сокращает время разработки.
- Моделирование реального мира: ООП позволяет создавать программы, которые более интуитивно понятны для людей, так как они отражают структуру реального мира.

### Смысл ООП
* Заставить объект способом на родительском уровне изменить нужную характеристику
* Научить объект новой функциональности, либо благодаря переносу функциональность в родительский класс, поделиться функционалом для объекта с которым мы хотим работать

### Пример
* Кошка и хамеллион могли выйти из одного родителя, но у кошки потерялась способность смены цвета по пути эволюции


## <a name="async"></a> Синхронность и асинхронность

### Принципы синхронности и асинхронности

Норма для обычных алгоритмов
Последовательный и блокирующий режим работы операторов.
- Модальные окна (MVI - Multi Dialog Interface и SDI - Single Dialog Interface)
- Неизбежные паузы ожидания ресурсов
- Длительность тяжелых расчетов (переборов)
Но как же идея "Паралельной работы"?

![alt](https://i.imgur.com/KHcEUhs.png)

### Асинхронное исполнение 

Распаралелливание действий + AJAX
Неизбежные риски "Задержек".
Активно используется на тех. уровне во множестве действий (+UI)
- Поиск, подгрузка, отправка данных
- Проверка, блокировка и обновление

> [!NOTE]
> В задачах аналитика нельзя реализовывать асинхронность средствами ЯП

![alt](https://i.imgur.com/EfUfH8o.png)

> [!NOTE]
> ЯП высокого уровня поддерживают создание вспомогательных потоков исполнения. 
> - В потоках появлется возможность запустить паралельные операторы, который оброщаются к проблемным данным, ресурсам, сведениям, дожидаются когда придут, но идея заключается в том, что основная программа продолжает свою работу, она предполагает когда в вспомогательном потоке отработает заложенные операторы, которые могут реагировать на паузы и поступление сведений на следующие обработки, основная программа выполняет просшуливание событий. Вспомогательные программы отрабатывают и отчитываются пепред главной, главная программа понимает что ее логика реализована и всеравно ждет, когда событие будет готово или выдаст ошибку из вспомогательного потока, после прихода результат, основная программа обновляет вывод.

## <a name="algdost"></a> Алгоритмический доступ к данным

Алгоритм получает доступ к данным

```Кнопки использовать ВСЕГДА, если нет нужного, можно написать, но кнопки важнее```

- к идентификатору: а + объявление ```def a ``` можно через кнопку ```var```, можно задавать параметр, например 100 ```def a:=100```
- к атрибутам: "Пример: " + ```Наименование``` ```Подразделение.Наименование``` через кнопку ```attr```
- к атрибуту объекта: ```obj.Город``` через кнопку ```attrByVar```, если делать через ```for``` уточняем объект через ```objects```
  ```
      for (def el : objects(Пиломатериалы) {
          printout( el.Спецификация )
      }
  ```
- к методам объектов: ```arr.size()```, подстановка ```arr``` через кнопку ```var```
  ```
      def arr:= []
      arr.add("Первый") // номер 0
      arr.add("Второй") // номер 1
      arr.add("Третий") // номер 2

      // пример вывода
      printout(arr[0]) // выведет ```Первый```
      printout(arr[2]) // выведет ```Третий```
  ```
- к коллекциям объектов: cl + заполнение коллекции кнопки ```objects``` ```objectsWithOptions```
- к элементам массива: arr[i] где i это от 0 до 2, пример выше
- к hash-структурам: hm.get(k)

## <a name="base"></a> Базовые операторы алгоритмов

Присваивание - внесение значений в идентификатор <br/>
Декларативное присваивание:
  ```
  def fio:="Неизвестный"
  def problem_count:=0
  def ob:=null
  def arr:=new ArrayList()
  ```
Присваивание:
  ```
  a:=(10+25)/total_count
  b:="Здравствуйте, " + fio + "!"
  i:=i+1
  ```

### Базовые операторы алгоритмов

Условная проверка - сравнение значения <br/>
Классическая проверка:
  ```
  if(условие) {
      операторы1
  }
  ```
> [!NOTE]
> Условные предикаты: `not или !` `and или &&` `or или ||`

Формы функциональных проверок:
  ```
  max_ab:=iif(a>b,a,b)
  is_completed:=proc>=100
  d:=a > b ? 1.5 : 1.3 // в ЯП могут также встречаться: case ..., switch...
  ```

Простое условие
```
  if(условие) {
    операторы1
  } else {
    операторы2
  }
```
Условие с уточнением
```
  if(условие1) {
    операторы1
  } else if(условие2) {
    операторы2
  }
```

Кнопки для базовых операторов  ```iif```, ```if```, ```else if```, ```else```, ```and```, ```or```, ```not```, ```isNull```, ```isNotNull```, ```true```, ```false```

Цикл - исполнение повторяющегося действия/блока действий

Арифметический цикл: `for` 
```
  for (def i:= 0; i < 50; i++) {
      операторы_тела_цикла
  }
```
Циклы перебора: для коллекций/структур `forEach`
```
  for (del el : набор_данных) {
      операторы_тела_цикла
  }
```
> [!WARNING]
> Применять прямое управление циклом неразумно `break` `continue`

Альтернативные циклы: требуют осторожности
```
  while (i < 1000) {
    операторы_тела_цикла
  }
```
>[!NOTE] 
> в ЯП могут встречаться: forEach..., do while..., do..., repeat...

Выдача - выдача контрольного текущего значения/результата работы

Печать в лог алгоритма:
```
  printout (значение)

  def s:=100
  printout('Сумма: ' + s + "руб. (НДФЛ "+0.13*s+")") // выведет -> `Сумма: 100руб. (НДФЛ 13.00)
```

Возврат результата: самим алгоритмом
```
  return идентификатор // с указанием директивы возврата
  идентификатор // сокращенный возврат (последним оператором)

  return 0.13*s // вывод -> 13
```

### Примеры:
```
def a := 100
def b := 150
def c := iif(a>b, a, b)

printout("max: " + c) // вывод -> 150
```
Неординарный способ (не для аналитиков)
```
def a := 100
def b := 150
def c := a > b ? a : b

printout("max: " + c) // вывод -> 150
```
Сумма чисел от 1 до n
```
def n := 12
def s := 0

for (def i:=1; i <= n; i++) {
    s := s + i
}

printout("s: " + s) // вывод -> 78
```
Сумма чисел от 1 до n (накполение в режиме конкотенации(строковый)) преобразование в строчный - `toString()`
```
def n := 12
def s := 0

for (def i:=1; i <= n; i++) {
    s := s.toString() + i.toString()
}

printout("s: " + s) // вывод -> 0123456789101112
```

```
def n := 12
def s := 0
def i := 1

while(i <= n) {
    s := s.toString() + i.toString()
    i++ // ОБЯЗАТЕЛЬНО ИНАЧЕ ЗАВИСНЕТ ВСЕ
}

printout("s: " + s)
```
```
def n := 12
def s := 0
def i := 1
def is_ok := true

while((i <= n) and (is_ok) {
    s := s.toString() + i.toString()
    if(i>5) {
       is_ok := false
    }
    i++
}

printout("s: " + s)
```
> [!WARNING]
> В `while` обязательно использовать `i++` если мы используем сравнение, чтобы мы могли закончить цикл, чтобы он не зациклился бесконечно
